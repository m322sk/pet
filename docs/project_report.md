# Пет-проект: аналитика кэшбэка Tinkoff Black

## 0. Входные данные

**Источник**: `tinkoff2_cashback.csv` + описание полей из `T_cashback_Описание_датасета.pdf`.

Ключевые особенности датасета:
- Месячная агрегация (апрель–сентябрь), в строке — клиент и месяц покупок.
- Для каждой категории есть три группы полей: **оборот**, **активация кэшбэка** и **полученный кэшбэк**.
- В полях активации встречаются пропуски (категория недоступна), 0 (доступна, но не выбрана), 1 (доступна и выбрана).

Эта специфика важна для очистки и интерпретации данных: значения `NULL` нельзя смешивать с `0` — это разные состояния выбора категории.

## 1. Работа с данными (SQL + немного Python)

### 1.1. Подготовка схемы
- **Staging-таблица** хранит сырые значения строками, чтобы не терять пропуски и избежать ошибок парсинга.
- **Нормализованная модель**:
  - `dim_clients` — уникальные клиенты.
  - `dim_months` — справочник месяцев.
  - `fact_cashback_category` — нормализованный факт (client_id, month, category).
  - `mart_client_month` — витрина клиент-месяц с агрегатами и QC-метриками.

PostgreSQL-скрипт схемы находится в `sql/postgres_01_schema.sql`.

### 1.2. Очистка
Цели очистки:
- привести типы (даты, целые, float),
- корректно отличить `NULL` от `0` в активациях,
- убрать дубликаты по ключу `(client_id, month)`
- закодировать состояние выбора как `activation_state` (`not_offered`, `offered_not_chosen`, `chosen`)

SQL очистки для PostgreSQL находится в `sql/postgres_02_cleaning.sql`.
Там же формируется QC-проверка: `eligible_cnt` должен быть 7 или 8, и строится
`has_subscription_guess` на основе количества доступных категорий.

### 1.3. Python-скрипт для выгрузки/проверок
`scripts/profile_data.py`:
- читает CSV стандартным модулем `csv`,
- считает базовые показатели качества (доля пропусков, дубликаты ключей),
- сохраняет сводку в `docs/data_quality_report.md`.

## 2. Дашборды (PostgreSQL как витрина)

Поскольку данные агрегированы по месяцам, я использую **MAU** вместо DAU/WAU.
Ключевые метрики:
- MAU по месяцам (активные клиенты с оборотом > 0)
- средний оборот по клиенту
- доля клиентов, активировавших кэшбэк в категории
- распределение оборотов по категориям

SQL для витрины в PostgreSQL — `sql/postgres_03_metrics.sql`.

## 3. Анализ эффекта (observational / quasi-experiment)

**Гипотеза**: клиенты, получившие категории с повышенным кэшбэком, увеличат оборот в этих категориях.

### 3.1. Важный дисклеймер
- В данных нет реального рандомизированного эксперимента.
- Категории с повышенным кэшбэком подбирались не случайно (есть подписка и 7/8 категорий).
- Поэтому причинные выводы делать нельзя — это **observational analysis**.

### 3.2. Подходы анализа
- **Within-user**: сравнение оборота в выбранной категории до/после выбора.
- **Нормировка** на общий оборот месяца, чтобы контролировать базовую активность.

SQL для PostgreSQL — `sql/postgres_04_ab_test.sql`.

### 3.3. Про t-test
`scripts/ab_test.py` оставлен как учебный пример техники, но в этом датасете
он не доказывает причинность. Для отчета я использую observational-подходы.

## 4. Пайплайн (PostgreSQL, batch/cron)

Цель — показать, как выстроить поток данных:
1. **Источник**: CSV загружается в PostgreSQL (основная БД).
2. **Transform**: очистка в PostgreSQL (`sql/postgres_02_cleaning.sql`).
3. **Materialized views / mart_***: витрины прямо в PostgreSQL (без отдельной БД).
4. **BI**: Superset/Redash подключаются к PostgreSQL.

Подробности в `docs/pipeline_design.md`.

## 5. Система алертов

- ежедневные алерты по провалам MAU и оборота,
- правило «3σ» для поиска аномалий,
- отправка в Telegram через cron/Airflow (описание и пример SQL).

SQL и правила для PostgreSQL — `sql/postgres_05_alerts.sql`, описание — `docs/alerts.md`.

---

## Как запустить

### Что понадобится
- **PostgreSQL** (основная БД), доступ через `psql` или DBeaver.
- **Python 3.10+**.
- Python-пакеты: `psycopg2-binary` (см. `requirements.txt`).
- (Опционально) **cron** или **Airflow** для регулярного запуска загрузки/обновления витрин.

### PostgreSQL (основная БД)
1. Создать таблицы:
```sql
source sql/postgres_01_schema.sql
```
2. Загрузить CSV в staging (пример через `psql`):
```sql
\\copy cashback.cashback_staging FROM 'tinkoff2_cashback.csv' WITH (FORMAT csv, HEADER true)
```
3. Установить зависимости Python:
```bash
python -m pip install -r requirements.txt
```
4. Очистить и наполнить модель:
```sql
source sql/postgres_02_cleaning.sql
```
5. Метрики и дашборды — `sql/postgres_03_metrics.sql`.
6. Observational-анализ — `sql/postgres_04_ab_test.sql`.
7. QC-проверка доступных категорий — последний запрос в `sql/postgres_02_cleaning.sql`.

### Пример cron (раз в час)
```cron
0 * * * * /usr/bin/psql "$PG_DSN" -f /path/to/project/sql/postgres_02_cleaning.sql >> /var/log/cashback_refresh.log 2>&1
```

## Ограничения данных
- Данные агрегированы по месяцам, нет транзакций/чеков.
- Нет формулы начисления кэшбэка и лимитов.
- Нет реального эксперимента, выводы — наблюдательные.
